[{"title":"Hello World","url":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"测试搜索功能文章","url":"/%E6%B5%8B%E8%AF%95%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%96%87%E7%AB%A0/","content":"测试搜索关键词这篇文章包含一些测试关键词：\n\n动态规划\n图论算法  \nC++ STL\n数据结构\n二叉树遍历\n\n代码示例#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5};\n    for (int num : nums) {\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\n","categories":["题解"],"tags":["测试","搜索"]},{"title":"系统测试文章","url":"/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","content":"测试内容这是一篇测试文章，用于验证系统修复是否成功。\n代码测试#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;\n    return 0;\n}\n\n","categories":["题解"],"tags":["测试"]},{"title":"常用算法模版(数据结构)","url":"/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"线段树#include&lt;bits/stdc++.h&gt;\n#define ls u&lt;&lt;1\n#define rs u&lt;&lt;1|1\nusing namespace std;\nusing ll=long long;\nconst int N=1e5+7;\nint n,m;\nll a[N];\nstruct Tree\n&#123;\n    int l,r;\n    ll sum,tag;\n&#125;tr[N&lt;&lt;2];//线段树数组\ninline void pushup(int u) &#123;tr[u].sum=tr[ls].sum+tr[rs].sum;&#125;//向上更新\nvoid pushdown(int u)//向下更新\n&#123;\n    if(tr[u].tag)//如果存在lazy_tag(即需要更新)\n    &#123;\n        Tree &amp;L=tr[ls],&amp;R=tr[rs];\n        int lenl=L.r-L.l+1;//计算左子节点区间长度\n        int lenr=R.r-R.l+1;//计算右子节点长度\n        //更新左子节点\n        L.tag+=tr[u].tag;//左子节点的lazy_tag增加\n        L.sum+=tr[u].tag*lenl;//左子节点的值增加\n        //更新右子节点\n        R.tag+=tr[u].tag;//左子节点的lazy_tag增加\n        R.sum+=tr[u].tag*lenr;//左子节点的值增加\n        //清空当前lazy_tag\n        tr[u].tag=0;\n    &#125;\n&#125;\nvoid build(int u,int l,int r)\n&#123;\n    tr[u]=&#123;l,r,0,0&#125;;//初始化节点\n    if(l==r)//到叶子结点\n    &#123;\n        tr[u].sum=a[l];//值等于其本身初始数组值\n        return;\n    &#125;\n    int mid=(l+r)&gt;&gt;1;//算中点\n    build(ls,l,mid);//递归更新左子树\n    build(rs,mid+1,r);//递归更新右子树\n    pushup(u);//更新当前节点\n&#125;\nvoid update(int u,int l,int r,ll v)\n&#123;\n    if(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)//完全被包含\n    &#123;\n        tr[u].tag+=v;//直接加lazy_tag\n        tr[u].sum+=v*(tr[u].r-tr[u].l+1);//更新节点值\n        return;\n    &#125;\n    pushdown(u);//向下更新\n    int mid=(tr[u].l+tr[u].r)&gt;&gt;1;//计算中点\n    if(l&lt;=mid) update(ls,l,r,v);//如果还需要更新则递归更新\n    if(r&gt;mid) update(rs,l,r,v);//如果还需要更新则递归更新\n    pushup(u);//向上更新本节点的值\n&#125;\nll query(int u,int l,int r)\n&#123;\n    if(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r) return tr[u].sum;//如果被完全包含则直接返回\n    pushdown(u);//向上更新本节点值\n    int mid=(tr[u].l+tr[u].r)&gt;&gt;1;//计算中点\n    ll res=0;//初始化答案值\n    if(l&lt;=mid) res+=query(ls,l,r);//如果还能拆分节点则递归累加\n    if(r&gt;mid) res+=query(rs,l,r);//如果还能拆分节点则递归累加\n    return res;\n&#125;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0); \n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];//原始数据\n    build(1,1,n);//建树,1表示根节点,1表示建树原数据起点,n表示终点\n    while(m--)\n    &#123;\n        int op,l,r;\n        ll v;\n        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;\n        if(op==1)\n        &#123;\n            cin&gt;&gt;v;\n            update(1,l,r,v);//根节点,区间起点,区间终点,加的值\n        &#125;\n            else cout&lt;&lt;query(1,l,r)&lt;&lt;&#x27;\\n&#x27;;//根节点,区间起点,区间终点\n    &#125;\n    return 0;\n&#125;\n树状数组#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=5e5+10;\nint n,m;\nint tr[N];//树状数组\ninline int lowbit(int x)&#123;return x&amp;-x;&#125;//求二进制下最左侧一个1\ninline void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x)) tr[x]+=v;&#125;//修改则给所有父节点值更新\nint query(int x)\n&#123;\n\tint res=0;\n\tfor(;x;x-=lowbit(x)) res+=tr[x];//从x节点出发的所有前缀值\n\treturn res;\n&#125;\nint main()\n&#123;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\tcin&gt;&gt;n&gt;&gt;m;\n\tfor(int i=1;i&lt;=n;i++)\n\t&#123;\n\t\tint x;\n\t\tcin&gt;&gt;x;\n\t\tadd(i,x);\n\t&#125;\n\twhile(m--)\n\t&#123;\n\t\tint op,x,y;\n\t\tcin&gt;&gt;op&gt;&gt;x&gt;&gt;y;\n\t\tif(op==1) add(x,y);\n    \t\telse cout&lt;&lt;query(y)-query(x-1)&lt;&lt;&#x27;\\n&#x27;;//差分求解\n\t&#125;\n\treturn 0;\n&#125;\n// P3374 【模板】树状数组 1\n并查集(路径压缩+按秩合并)#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=2e5+5;\nint n,q;\nint fa[N],r[N];\n// 查询+路径压缩 - 返回根节点编号\ninline int find(int x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;\n// 合并操作\nvoid merge(int x,int y)\n&#123;\n    x=find(x),y=find(y);//找到x和y的根节点\n    if(x==y) return;//如果已经在同一集合，直接返回\n    if(r[x]&lt;r[y]) fa[x]=y;//将秩小的树合并到秩大的树下\n        else \n        &#123;\n            fa[y]=x;//将y的根节点指向x的根节点\n            if(r[x]==r[y]) r[x]++;//如果秩相等，合并后秩加1\n        &#125;\n&#125;\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    cin&gt;&gt;n&gt;&gt;q;\n    for(int i=1;i&lt;=n;i++) \n    &#123;\n        fa[i]=i;//初始每个节点的父亲是其本身\n        r[i]=0;//初始每个节点的秩为0\n    &#125;\n    while(q--)\n    &#123;\n        int op,x,y;\n        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;//这里必须读取x,y\n        if(op==1) merge(x,y);//合并操作\n            else cout&lt;&lt;(find(x)==find(y)?&quot;Y\\n&quot;:&quot;N\\n&quot;);//查询是否在同一集合\n    &#125;\n    return 0;\n&#125;\n拓扑排序#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N=1e5+10;\nint n;\nint ind[N],ans[N];\nqueue&lt;int&gt; q;//改为priority_queue则可求字典序的拓扑排序\nvector&lt;int&gt; g[N];\nint main()\n&#123;\n    ios::sync_with_stdio(false);\n    cin.tie(0);cout.tie(0);\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;i++)\n    &#123;\n        int child;\n        while(cin&gt;&gt;child&amp;&amp;child!=0)\n        &#123;\n            g[i].push_back(child);//建立单向图\n            ind[child]++;//child的入度+1\n        &#125;\n    &#125;\n    for(int i=1;i&lt;=n;i++)\n        if(ind[i]==0) q.push(i);//入度为1的为初始操作点\n    int cnt=0;//答案下标\n    while(!q.empty())\n    &#123;\n        int u=q.front();//取出当前节点\n        q.pop();//弹出节点\n        ans[++cnt]=u;//记录答案\n        for(int v:g[u])\n        &#123;\n            ind[v]--;//解锁\n            if(ind[v] == 0) q.push(v);//当前节点可以执行则加入队列\n        &#125;\n    &#125;\n    if(cnt!=n) cout&lt;&lt; &quot;-1&quot;;//答案不到n说明无合法拓扑序\n        else for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;//有则输出答案\n    return 0;\n&#125;","categories":["模板"],"tags":["模板","数据结构","线段树","树状数组","并查集","拓扑排序"]}]