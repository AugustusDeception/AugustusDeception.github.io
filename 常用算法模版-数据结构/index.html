<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>常用算法模版(数据结构) | AugustusDeception 的 OI 博客</title><meta name="author" content="AugustusDeception"><meta name="copyright" content="AugustusDeception"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线段树#include<bits/stdc++.h> #define ls u<<1 #define rs u<<1|1 using namespace std; using ll=long long; const int N=1e5+7; int n,m; ll a[N]; struct Tree {     int l,r;     ll sum,"><meta property="og:type" content="article"><meta property="og:title" content="常用算法模版(数据结构)"><meta property="og:url" content="https://augustusdeception.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><meta property="og:site_name" content="AugustusDeception 的 OI 博客"><meta property="og:description" content="线段树#include<bits/stdc++.h> #define ls u<<1 #define rs u<<1|1 using namespace std; using ll=long long; const int N=1e5+7; int n,m; ll a[N]; struct Tree {     int l,r;     ll sum,"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://augustusdeception.github.io/img/butterfly-icon.png"><meta property="article:published_time" content="2025-11-23T12:00:00.000Z"><meta property="article:modified_time" content="2025-11-23T14:40:11.501Z"><meta property="article:author" content="AugustusDeception"><meta property="article:tag" content="并查集"><meta property="article:tag" content="拓扑排序"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="树状数组"><meta property="article:tag" content="模板"><meta property="article:tag" content="线段树"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://augustusdeception.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常用算法模版(数据结构)",
  "url": "https://augustusdeception.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
  "image": "https://augustusdeception.github.io/img/butterfly-icon.png",
  "datePublished": "2025-11-23T12:00:00.000Z",
  "dateModified": "2025-11-23T14:40:11.501Z",
  "author": [
    {
      "@type": "Person",
      "name": "AugustusDeception",
      "url": "https://AugustusDeception.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://augustusdeception.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><script>(()=>{var e={set:(e,t,a)=>{a&&(a=Date.now()+864e5*a,localStorage.setItem(e,JSON.stringify({value:t,expiry:a})))},get:e=>{var t=localStorage.getItem(e);if(t){var{value:t,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return t;localStorage.removeItem(e)}}},t=(window.btf={saveToLocal:e,getScript:(o,n={})=>new Promise((e,t)=>{let a=document.createElement("script");a.src=o,a.async=!0,Object.entries(n).forEach(([e,t])=>a.setAttribute(e,t)),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),getCSS:(o,n)=>new Promise((e,t)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onload=a.onreadystatechange=()=>{a.readyState&&!/loaded|complete/.test(a.readyState)||e()},a.onerror=t,document.head.appendChild(a)}),addGlobalFn:(e,t,a=!1,o=window)=>{var n;e.startsWith("pjax")||((n=o.globalFn||{})[e]=n[e]||{},n[e][a||Object.keys(n[e]).length]=t,o.globalFn=n)}},()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")}),a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","undefined")},o=(btf.activateDarkMode=t,btf.activateLightMode=a,e.get("theme")),t=("dark"===o?t():"light"===o&&a(),e.get("aside-status"));void 0!==t&&document.documentElement.classList.toggle("hide-aside","hide"===t);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>let GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"常用算法模版(数据结构)",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 8.1.1"><script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css"></noscript></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/algorithms/"><i class="fa-fw fas fa-sitemap"></i><span> 算法索引</span></a></div><div class="menus_item"><a class="site-page" href="/oj-platforms/"><i class="fa-fw fas fa-laptop-code"></i><span> OJ平台</span></a></div><div class="menus_item"><a class="site-page" href="/tags/%E9%A2%98%E8%A7%A3/"><i class="fa-fw fas fa-code"></i><span> 题解集</span></a></div><div class="menus_item"><a class="site-page" href="/tags/%E6%AF%94%E8%B5%9B/"><i class="fa-fw fas fa-trophy"></i><span> 比赛记录</span></a></div><div class="menus_item"><a class="site-page" href="/templates/"><i class="fa-fw fas fa-file-code"></i><span> 模板库</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AugustusDeception 的 OI 博客</span></a><a class="nav-page-title" href="/"><span class="site-name">常用算法模版(数据结构)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> 返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/algorithms/"><i class="fa-fw fas fa-sitemap"></i><span> 算法索引</span></a></div><div class="menus_item"><a class="site-page" href="/oj-platforms/"><i class="fa-fw fas fa-laptop-code"></i><span> OJ平台</span></a></div><div class="menus_item"><a class="site-page" href="/tags/%E9%A2%98%E8%A7%A3/"><i class="fa-fw fas fa-code"></i><span> 题解集</span></a></div><div class="menus_item"><a class="site-page" href="/tags/%E6%AF%94%E8%B5%9B/"><i class="fa-fw fas fa-trophy"></i><span> 比赛记录</span></a></div><div class="menus_item"><a class="site-page" href="/templates/"><i class="fa-fw fas fa-file-code"></i><span> 模板库</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">常用算法模版(数据结构)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-23T12:00:00.000Z" title="发表于 2025-11-23 20:00:00">2025-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-23T14:40:11.501Z" title="更新于 2025-11-23 22:40:11">2025-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>
<span class="meta">#<span class="keyword">define</span> ls u&lt;&lt;1</span>
<span class="meta">#<span class="keyword">define</span> rs u&lt;&lt;1|1</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> std;
<span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;
<span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+7</span>;
<span class="type">int</span> n,m;
ll a[N];
<span class="keyword">struct</span> <span class="title class_">Tree</span>
{
    <span class="type">int</span> l,r;
    ll sum,tag;
}tr[N&lt;&lt;<span class="number">2</span>];<span class="comment">//线段树数组</span>
<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>{tr[u].sum=tr[ls].sum+tr[rs].sum;}<span class="comment">//向上更新</span>
<span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//向下更新</span></span>
<span class="function"></span>{
    <span class="keyword">if</span>(tr[u].tag)<span class="comment">//如果存在lazy_tag(即需要更新)</span>
    {
        Tree &amp;L=tr[ls],&amp;R=tr[rs];
        <span class="type">int</span> lenl=L.r-L.l<span class="number">+1</span>;<span class="comment">//计算左子节点区间长度</span>
        <span class="type">int</span> lenr=R.r-R.l<span class="number">+1</span>;<span class="comment">//计算右子节点长度</span>
        <span class="comment">//更新左子节点</span>
        L.tag+=tr[u].tag;<span class="comment">//左子节点的lazy_tag增加</span>
        L.sum+=tr[u].tag*lenl;<span class="comment">//左子节点的值增加</span>
        <span class="comment">//更新右子节点</span>
        R.tag+=tr[u].tag;<span class="comment">//左子节点的lazy_tag增加</span>
        R.sum+=tr[u].tag*lenr;<span class="comment">//左子节点的值增加</span>
        <span class="comment">//清空当前lazy_tag</span>
        tr[u].tag=<span class="number">0</span>;
    }
}
<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>
<span class="function"></span>{
    tr[u]={l,r,<span class="number">0</span>,<span class="number">0</span>};<span class="comment">//初始化节点</span>
    <span class="keyword">if</span>(l==r)<span class="comment">//到叶子结点</span>
    {
        tr[u].sum=a[l];<span class="comment">//值等于其本身初始数组值</span>
        <span class="keyword">return</span>;
    }
    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="comment">//算中点</span>
    <span class="built_in">build</span>(ls,l,mid);<span class="comment">//递归更新左子树</span>
    <span class="built_in">build</span>(rs,mid<span class="number">+1</span>,r);<span class="comment">//递归更新右子树</span>
    <span class="built_in">pushup</span>(u);<span class="comment">//更新当前节点</span>
}
<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,ll v)</span></span>
<span class="function"></span>{
    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)<span class="comment">//完全被包含</span>
    {
        tr[u].tag+=v;<span class="comment">//直接加lazy_tag</span>
        tr[u].sum+=v*(tr[u].r-tr[u].l<span class="number">+1</span>);<span class="comment">//更新节点值</span>
        <span class="keyword">return</span>;
    }
    <span class="built_in">pushdown</span>(u);<span class="comment">//向下更新</span>
    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;<span class="comment">//计算中点</span>
    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">update</span>(ls,l,r,v);<span class="comment">//如果还需要更新则递归更新</span>
    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">update</span>(rs,l,r,v);<span class="comment">//如果还需要更新则递归更新</span>
    <span class="built_in">pushup</span>(u);<span class="comment">//向上更新本节点的值</span>
}
<span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>
<span class="function"></span>{
    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;<span class="comment">//如果被完全包含则直接返回</span>
    <span class="built_in">pushdown</span>(u);<span class="comment">//向上更新本节点值</span>
    <span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;<span class="comment">//计算中点</span>
    ll res=<span class="number">0</span>;<span class="comment">//初始化答案值</span>
    <span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">query</span>(ls,l,r);<span class="comment">//如果还能拆分节点则递归累加</span>
    <span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rs,l,r);<span class="comment">//如果还能拆分节点则递归累加</span>
    <span class="keyword">return</span> res;
}
<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);
    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>); 
    cin&gt;&gt;n&gt;&gt;m;
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<span class="comment">//原始数据</span>
    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//建树,1表示根节点,1表示建树原数据起点,n表示终点</span>
    <span class="keyword">while</span>(m--)
    {
        <span class="type">int</span> op,l,r;
        ll v;
        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;
        <span class="keyword">if</span>(op==<span class="number">1</span>)
        {
            cin&gt;&gt;v;
            <span class="built_in">update</span>(<span class="number">1</span>,l,r,v);<span class="comment">//根节点,区间起点,区间终点,加的值</span>
        }
            <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//根节点,区间起点,区间终点</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> std;
<span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;
<span class="type">int</span> n,m;
<span class="type">int</span> tr[N];<span class="comment">//树状数组</span>
<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>{<span class="keyword">return</span> x&amp;-x;}<span class="comment">//求二进制下最左侧一个1</span>
<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>{<span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) tr[x]+=v;}<span class="comment">//修改则给所有父节点值更新</span>
<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>
<span class="function"></span>{
	<span class="type">int</span> res=<span class="number">0</span>;
	<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) res+=tr[x];<span class="comment">//从x节点出发的所有前缀值</span>
	<span class="keyword">return</span> res;
}
<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);
	cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);
	cin&gt;&gt;n&gt;&gt;m;
	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
	{
		<span class="type">int</span> x;
		cin&gt;&gt;x;
		<span class="built_in">add</span>(i,x);
	}
	<span class="keyword">while</span>(m--)
	{
		<span class="type">int</span> op,x,y;
		cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
		<span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">add</span>(x,y);
    		<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>)&lt;&lt;<span class="string">'\n'</span>;<span class="comment">//差分求解</span>
	}
	<span class="keyword">return</span> <span class="number">0</span>;
}
<span class="comment">// P3374 【模板】树状数组 1</span></code></pre><h3 id="并查集-路径压缩-按秩合并"><a href="#并查集-路径压缩-按秩合并" class="headerlink" title="并查集(路径压缩+按秩合并)"></a>并查集(路径压缩+按秩合并)</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> std;
<span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;
<span class="type">int</span> n,q;
<span class="type">int</span> fa[N],r[N];
<span class="comment">// 查询+路径压缩 - 返回根节点编号</span>
<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>{<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);}
<span class="comment">// 合并操作</span>
<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>
<span class="function"></span>{
    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);<span class="comment">//找到x和y的根节点</span>
    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;<span class="comment">//如果已经在同一集合，直接返回</span>
    <span class="keyword">if</span>(r[x]&lt;r[y]) fa[x]=y;<span class="comment">//将秩小的树合并到秩大的树下</span>
        <span class="keyword">else</span> 
        {
            fa[y]=x;<span class="comment">//将y的根节点指向x的根节点</span>
            <span class="keyword">if</span>(r[x]==r[y]) r[x]++;<span class="comment">//如果秩相等，合并后秩加1</span>
        }
}
<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);
    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);
    cin&gt;&gt;n&gt;&gt;q;
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) 
    {
        fa[i]=i;<span class="comment">//初始每个节点的父亲是其本身</span>
        r[i]=<span class="number">0</span>;<span class="comment">//初始每个节点的秩为0</span>
    }
    <span class="keyword">while</span>(q--)
    {
        <span class="type">int</span> op,x,y;
        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;<span class="comment">//这里必须读取x,y</span>
        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">merge</span>(x,y);<span class="comment">//合并操作</span>
            <span class="keyword">else</span> cout&lt;&lt;(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)?<span class="string">"Y\n"</span>:<span class="string">"N\n"</span>);<span class="comment">//查询是否在同一集合</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> std;
<span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;
<span class="type">int</span> n;
<span class="type">int</span> ind[N],ans[N];
queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//改为priority_queue则可求字典序的拓扑排序</span>
vector&lt;<span class="type">int</span>&gt; g[N];
<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>
<span class="function"></span>{
    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);
    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);
    cin&gt;&gt;n;
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
    {
        <span class="type">int</span> child;
        <span class="keyword">while</span>(cin&gt;&gt;child&amp;&amp;child!=<span class="number">0</span>)
        {
            g[i].<span class="built_in">push_back</span>(child);<span class="comment">//建立单向图</span>
            ind[child]++;<span class="comment">//child的入度+1</span>
        }
    }
    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)
        <span class="keyword">if</span>(ind[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);<span class="comment">//入度为1的为初始操作点</span>
    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//答案下标</span>
    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())
    {
        <span class="type">int</span> u=q.<span class="built_in">front</span>();<span class="comment">//取出当前节点</span>
        q.<span class="built_in">pop</span>();<span class="comment">//弹出节点</span>
        ans[++cnt]=u;<span class="comment">//记录答案</span>
        <span class="keyword">for</span>(<span class="type">int</span> v:g[u])
        {
            ind[v]--;<span class="comment">//解锁</span>
            <span class="keyword">if</span>(ind[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);<span class="comment">//当前节点可以执行则加入队列</span>
        }
    }
    <span class="keyword">if</span>(cnt!=n) cout&lt;&lt; <span class="string">"-1"</span>;<span class="comment">//答案不到n说明无合法拓扑序</span>
        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;<span class="comment">//有则输出答案</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://AugustusDeception.github.io">AugustusDeception</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://augustusdeception.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://augustusdeception.github.io/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://AugustusDeception.github.io" target="_blank">AugustusDeception 的 OI 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A8%A1%E6%9D%BF/">模板</a><a class="post-meta__tags" href="/tags/data-structure/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a><a class="post-meta__tags" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">树状数组</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a><a class="post-meta__tags" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9-%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6"><span class="toc-number">3.</span> <span class="toc-text">并查集(路径压缩+按秩合并)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">拓扑排序</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 By AugustusDeception</span></div><div class="footer_custom_text">专注于 C++ 和算法竞赛</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><div class="js-pjax"></div></div><script src="/bundle.js"></script></body></html>